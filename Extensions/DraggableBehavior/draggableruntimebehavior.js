var gdjs;(function(n){class s extends n.RuntimeBehavior{constructor(e,t,a){super(e,t,a);this._draggedByDraggableManager=null;this._justDropped=!1;this._checkCollisionMask=!!t.checkCollisionMask}updateFromBehaviorData(e,t){return!0}onDeActivate(){this._endDrag()}onDestroy(){this.onDeActivate()}_endDrag(){this._draggedByDraggableManager&&(this._draggedByDraggableManager.endDrag(),this._justDropped=!0),this._draggedByDraggableManager=null}_dismissDrag(){this._draggedByDraggableManager=null}_tryBeginDrag(e){if(this._draggedByDraggableManager)return!1;const a=e.getGame().getInputManager().getStartedTouchIdentifiers();for(let r=0;r<a.length;++r){const i=g.getTouchManager(e,a[r]);if(!i.isDragging(this)&&i.tryAndTakeDragging(e,this))return this._draggedByDraggableManager=i,!0}return!1}_shouldEndDrag(e){return this._draggedByDraggableManager?this._draggedByDraggableManager.shouldEndDrag(e,this):!1}_updateObjectPosition(e){return this._draggedByDraggableManager?(this._draggedByDraggableManager.updateObjectPosition(e,this),!0):!1}doStepPreEvents(e){this._tryBeginDrag(e),this._shouldEndDrag(e)&&this._endDrag(),this._updateObjectPosition(e)}doStepPostEvents(e){this._justDropped=!1}isDragged(){return!!this._draggedByDraggableManager}wasJustDropped(){return this._justDropped}}n.DraggableRuntimeBehavior=s;class g{constructor(e,t){this._draggingSomething=!1;this._draggableBehavior=null;this._xOffset=0;this._yOffset=0;this._touchId=t}static getTouchManager(e,t){return e.touchDraggableManagers||(e.touchDraggableManagers=[]),e.touchDraggableManagers[t]||(e.touchDraggableManagers[t]=new g(e,t)),e.touchDraggableManagers[t]}tryAndTakeDragging(e,t){if(this._draggableBehavior&&t.owner.getZOrder()<=this._draggableBehavior.owner.getZOrder())return!1;const a=this.getPosition(e,t);if(t.owner.insideObject(a[0],a[1])){if(t._checkCollisionMask&&!t.owner.isCollidingWithPoint(a[0],a[1]))return!1}else return!1;return this._draggableBehavior&&this._draggableBehavior._dismissDrag(),this._draggableBehavior=t,this._xOffset=a[0]-t.owner.getX(),this._yOffset=a[1]-t.owner.getY(),!0}updateObjectPosition(e,t){const a=this.getPosition(e,t);(t.owner.getX()!=a[0]-this._xOffset||t.owner.getY()!=a[1]-this._yOffset)&&(t.owner.setX(a[0]-this._xOffset),t.owner.setY(a[1]-this._yOffset),this._draggingSomething=!0)}endDrag(){this._draggingSomething=!1,this._draggableBehavior=null}isDragging(e){return this._draggingSomething}getPosition(e,t){const a=n.staticArray(g.prototype.getPosition),r=e.getGame().getInputManager();return e.getLayer(t.owner.getLayer()).convertCoords(r.getTouchX(this._touchId),r.getTouchY(this._touchId),0,a)}shouldEndDrag(e,t){return e.getGame().getInputManager().hasTouchEnded(this._touchId)}}n.registerBehavior("DraggableBehavior::Draggable",n.DraggableRuntimeBehavior)})(gdjs||(gdjs={}));
//# sourceMappingURL=draggableruntimebehavior.js.map
